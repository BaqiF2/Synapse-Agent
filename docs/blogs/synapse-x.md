Synapse Agent：统一 Shell 抽象与技能进化

如果大脑是一台生物计算机，那神经突触就是它的编程语言——每一次学习，都是在重写突触连接的权重。

【一、Synapse——神经突触】

我从零构建了一个会"学习"的 AI Agent 框架：Synapse Agent。名字来自神经科学——突触（Synapse）是两个神经元之间的连接点，不仅传递信号，本身就是记忆的载体。"一起激活的神经元会连接在一起"，Hebbian Learning 法则是整个神经可塑性的基石，也是这个项目的核心隐喻。

过去一年我深度使用了 Claude Code、Cursor 等工具，研究了多个 Agent 框架，一个问题反复浮现：现在的 Agent 每次对话都在"失忆"。它们像一个每天醒来就忘记前一天经验的实习生，永远在重复学习同样的东西。能不能造一个不靠暴力扩大上下文窗口，而是像大脑一样把反复出现的模式沉淀为稳定突触连接的 Agent？带着这个问题，我从零开始构建了 Synapse。

【二、八条核心直觉】

项目启动前，我写下了八条关于 Agent 的核心直觉，分为两类。

已知定律——三条从实践中确认的事实：
① 工具就是 Agent 的手脚，没有工具的 Agent 只是聊天机器人
② 文件系统是一种记忆，天然具备跨会话持久性
③ 技能 = 文件系统 + 工具，把经验写成文件、操作封装为工具，就是可复用的技能

需要证明的命题——五条假设，Synapse 的设计就是对它们的逐一验证：
④ 一切工具都是 Bash → 三层 Shell 架构
⑤ 一切都是工具 → 子任务、技能管理全部封装为命令
⑥ 技能 + LLM = 大脑 → 技能系统的自我学习与记忆
⑦ 技能 + LLM + Bash = 通用智能体 → 技能中的工具自动转化为 Shell Command
⑧ 沙盒 = 一种工作台 → 安全执行环境，重要但非核心

【三、命题一：一切工具都是 Shell Command】

▍问题：工具爆炸

主流框架给 LLM 提供大量工具定义，读文件一个工具，写文件一个工具，搜索一个工具，每个都有一段 JSON Schema。对 LLM 来说每多一个工具就多一重选择负担——如果你的大脑每次抬手都要先从清单里选用哪块肌肉，你连杯水都端不起来。能不能让 LLM 只学一个工具？

▍灵感：运动皮层与 Unix 哲学

灵感来自两个地方。人类的运动皮层——大脑只有一个运动中枢却能协调 600 多块肌肉，不需要为每块肌肉设计独立决策模块，只需发出高层意图，底层自动路由。Unix 哲学——"一切皆文件"，统一抽象让一切操作都可以用 read/write 完成。类比到 Agent："一切工具皆 Shell Command"。Shell 是人类用了 50 年的工具协议，LLM 天生理解 ls、git、curl。与其教 LLM 学全新的工具 API，不如让所有工具说 Shell 的语言。

▍三层架构：神经通路的三种类型

Synapse 设计了三层架构，对应神经通路的三种类型：

Layer 1 · 先天反射（Native Shell）—— ls、git、npm、curl，操作系统自带的命令，零适配成本，直接复用整个 Unix 生态。

Layer 2 · 后天习得（Agent Shell）—— read、write、edit、task:explore、skill:load，为 Agent 专门设计的命令，封装文件操作、子任务分发、技能管理等能力。

Layer 3 · 跨模态迁移（Extension Shell）—— mcp:github:create_issue、skill:blog-writer:generate，外部工具自动包装成命令，MCP 协议工具和 Skill 脚本都被自动转化为 Shell Command，对 LLM 完全透明。

▍BashRouter：注意力机制

BashRouter 是架构的关键枢纽，类似 Transformer 中的注意力机制——根据输入命令模式自动路由到对应处理器。以 mcp: 开头走 Extension Shell，匹配注册表走 Agent Shell，都不匹配就直接作为 Native Shell 执行。LLM 不需要知道背后有三层处理器，只管输入命令。

▍效果对比

传统方案：N 个工具，N 段 JSON Schema → Synapse：1 个 BashTool，22 行描述
传统方案：新增工具需新增 Schema，LLM 重新学习 → Synapse：新增命令前缀，无需修改工具定义
传统方案：LLM 认知负担随工具数量线性增长 → Synapse：恒定不变

▍扩展命令的统一包装

外部工具怎么变成 Shell Command？自动包装。McpWrapperGenerator 把 MCP Server 的 tools 转换为 mcp:server:tool 格式，SkillWrapperGenerator 把技能脚本转换为 skill:name:action 格式。都支持 --help 和位置参数。LLM 只看到命令名和帮助输出——就像手不需要知道是肌肉在收缩还是肌腱在传力，大脑只需说"抓住杯子"。

▍按需检索：海马体的线索回忆

扩展工具那么多，Agent 怎么知道有哪些可用？答案是它不知道，直到需要时去搜。Agent 启动时只带 Layer 1 和 Layer 2 的基础能力，遇到需要额外工具的任务时主动调用 command:search 在三层工具库中搜索。这就像海马体检索机制——你不会把所有记忆都放在意识前台，而是通过线索触发回忆。工具库可以无限扩展，但上下文成本恒定。

【四、命题二：技能 + LLM = 大脑】

▍问题：Agent 没有记忆

统一 Shell 解决了"如何行动"，技能系统解决"如何记忆"。现在的 LLM Agent 每次对话都是失忆状态，只有工作记忆没有长期记忆——能在当下解决问题，但无法把经验带到未来。人类靠写笔记、整理 SOP 把短期经验沉淀为长期知识，Agent 也应该可以。

▍设计思路：文件系统就是突触权重

核心公式：技能 = 文件系统 + 工具。LLM 的参数是大脑的先天结构，文件系统就是后天形成的突触权重。技能文件持久化在磁盘上，跨会话保持，每次对话后可被更新强化——学习让突触连接变得更强。

▍技能的结构

每个技能是一个自包含目录：SKILL.md 是技能说明书，何时触发怎么执行；scripts/ 放可执行脚本，把确定性操作固化避免 LLM 每次重写；references/ 放领域知识文档按需加载；assets/ 放模板和资源文件。

▍技能搜索与渐进式加载

Synapse 不会预加载任何技能，Agent 启动时对技能库一无所知，甚至不知道自己"会什么"。遇到复杂任务时第一步是搜索——启动子智能体 task:skill:search 在技能库中语义匹配，然后用精确名称 skill:load 加载。

三级检索机制，对应大脑从线索到完整回忆的过程：
· Level 0 搜索——Agent 通过子智能体语义检索，就像海马体通过线索搜索长期记忆
· Level 1 加载 SKILL.md——相当于"回忆起"一段知识
· Level 2 脚本和参考资料按需读取——相当于在回忆基础上翻阅详细笔记

关键规则：永远不要猜测技能名称，必须先搜后用。

▍技能进化的三种方式

大脑通过神经可塑性不断重塑自己，Agent 的技能进化也有三种对应方式：

方式一 · Hebbian Learning——自动技能增强。"一起激活的神经元会连接在一起。"Agent 完成任务后 SkillEnhancer 分析对话历史，检测工具使用模式，反复出现的"读文件→分析→写报告"会被固化为技能。这是在线学习，Agent 在执行中持续更新自己的技能库。

方式二 · 前额叶皮层——元技能指导。两个元技能 skill-creator 和 skill-enhance，指导 Agent 创建和优化技能。技能在教 Agent 创造更好的技能，形成自举循环——就像元认知让人类不断改善学习方法。

方式三 · RLHF——用户主动导入。用户通过 skill:import 从本地或 GitHub 导入优质技能，每次导入都是一个奖励信号告诉 Agent"这是好的做法"。自动增强是 Agent 自己摸索学到的，用户导入是人类直接把正确答案交给 Agent，两者互补构成完整学习闭环。

【五、命题三：一切都是工具】

在 Agent Loop 中给 Agent 加新能力，先把它封装为工具。子智能体是工具（task:explore），技能搜索是工具（task:skill:search），技能管理是工具（skill:load），工具搜索也是工具（command:search）。

为什么不硬编码？因为工具化意味着 LLM 自主决策——Agent 根据上下文判断是否需要搜索、加载、分发，而不是被固定流程驱动。就像大脑中一切都是神经信号，在 Synapse 中一切能力都是 Shell Command 在 BashRouter 中流动。

【六、协同效应：完整的神经系统】

当统一 Shell、技能系统和一切工具化组合在一起，产生协同效应。完整的任务流程：

① 用户输入 → Agent Runner
② LLM 评估复杂度，决定是否需要搜索技能和工具
③ 搜索：task:skill:search 在技能库中语义匹配，command:search 在工具库中检索
④ 加载：用搜索返回的精确名称 skill:load 加载技能指令
⑤ LLM 推理后输出 Shell Command，BashRouter 自动路由执行
⑥ 按需调用 task:explore 分发子任务
⑦ 任务完成后 SkillEnhancer 分析并增强技能，持久化到文件系统

每个组件各司其职，通过统一 Shell 抽象连接——就像大脑不同区域通过神经通路协同工作。

【七、从直觉到验证】

回顾八条直觉：
✅ 工具是手脚 / 文件系统是记忆 / 技能 = 文件 + 工具 —— 已知定律，无需证明
✅ 一切工具都是 Bash —— 三层架构成功运行
✅ 一切都是工具 —— 子任务和技能管理全部工具化
✅ 技能 + LLM = 大脑 —— 三种进化方式协同工作
🔄 技能 + LLM + Bash = 通用智能体 —— 持续验证中
✅ 沙盒 = 工作台 —— 重要但非核心，就像安全帽，工程必备但不是建筑本身

Synapse 目前仍是一个婴儿期的个人项目，更多体现了我对 Agent 的期望和想象。但它验证了一些重要的设计理念：技能市场让 Agent 生成和共享技能形成技能应用商店；多 Agent 协作从三类子智能体扩展为更复杂的协作拓扑；持续进化让 Agent 像生物一样在使用中不断适应和成长。

【结语】

为什么这个时候开源？看到了 Obsidian CLI 的发布有异曲同工之处，就把最近的思考和实践分享出来。未来我会把它打造得更加成熟，加油！

突触每一次激活，都在让连接变得更强。

github.com/BaqiF2/Synapse-Agent
