/**
 * 文件功能说明：
 * - 该文件位于 `src/tools/converters/mcp/wrapper-generator.ts`，主要负责 封装、generator 相关实现。
 * - 模块归属 工具、转换器、MCP 领域，为上层流程提供可复用能力。
 *
 * 核心导出列表：
 * - `McpWrapperGenerator`
 * - `WrapperGeneratorOptions`
 * - `GeneratedWrapper`
 *
 * 作用说明：
 * - `McpWrapperGenerator`：封装该领域的核心流程与状态管理。
 * - `WrapperGeneratorOptions`：定义模块交互的数据结构契约。
 * - `GeneratedWrapper`：定义模块交互的数据结构契约。
 */

import type { McpToolInfo } from './mcp-client.js';
import { generateBriefHelp, generateDetailedHelp, type HelpParam } from '../shared/help-generator.ts';

/** JSON Schema 属性 */
interface SchemaProperty {
  type?: string;
  description?: string;
  default?: unknown;
  enum?: unknown[];
}

/** JSON Schema for tool input */
interface ToolInputSchema {
  type?: string;
  properties?: Record<string, SchemaProperty>;
  required?: string[];
}

/** 生成器配置选项 */
export interface WrapperGeneratorOptions {
  binDir?: string;
  callerPath?: string;
}

/** 生成的 wrapper 元数据 */
export interface GeneratedWrapper {
  commandName: string;
  serverName: string;
  toolName: string;
  scriptPath: string;
  content: string;
  description?: string;
}

const DEFAULT_BIN_DIR = '~/.synapse/bin';

/**
 * McpWrapperGenerator — MCP 工具 wrapper 脚本生成器
 *
 * 为每个 MCP 工具生成：
 * - 基于 inputSchema 的 CLI 参数解析
 * - -h / --help 帮助信息
 * - MCP 工具调用输出
 */
export class McpWrapperGenerator {
  private options: Required<WrapperGeneratorOptions>;

  /**
   * 方法说明：初始化 McpWrapperGenerator 实例并设置初始状态。
   * @param options 配置参数。
   */
  constructor(options: WrapperGeneratorOptions = {}) {
    this.options = {
      binDir: options.binDir ?? DEFAULT_BIN_DIR,
      callerPath: options.callerPath ?? '',
    };
  }

  /** 为单个工具生成 wrapper
   * @param serverName 输入参数。
   * @param tool 输入参数。
   */
  public generateWrapper(serverName: string, tool: McpToolInfo): GeneratedWrapper {
    const commandName = `mcp:${serverName}:${tool.name}`;
    const content = this.generateScriptContent(serverName, tool);
    const binDir = this.options.binDir.replace(/^~/, process.env.HOME || '');
    const scriptPath = `${binDir}/${commandName}`;

    return { commandName, serverName, toolName: tool.name, scriptPath, content, description: tool.description };
  }

  /** 为服务器所有工具批量生成 wrapper
   * @param serverName 输入参数。
   * @param tools 集合数据。
   */
  public generateWrappers(serverName: string, tools: McpToolInfo[]): GeneratedWrapper[] {
    return tools.map((tool) => this.generateWrapper(serverName, tool));
  }

  // -- 私有方法 --

  /** 从 JSON Schema 提取参数信息并转为 HelpParam
   * @param schema 输入参数。
   */
  private extractParams(schema: ToolInputSchema): HelpParam[] {
    const properties = schema.properties || {};
    const required = new Set(schema.required || []);
    const params: HelpParam[] = [];

    for (const [name, prop] of Object.entries(properties)) {
      params.push({
        name,
        type: prop.type || 'string',
        description: prop.description || '',
        required: required.has(name),
        defaultValue: prop.default,
        enumValues: prop.enum,
      });
    }

    // 排序：必选在前，然后按字母序
    params.sort((a, b) => {
      if (a.required !== b.required) return a.required ? -1 : 1;
      return a.name.localeCompare(b.name);
    });

    return params;
  }

  /** 生成 wrapper 脚本内容
   * @param serverName 输入参数。
   * @param tool 输入参数。
   */
  private generateScriptContent(serverName: string, tool: McpToolInfo): string {
    const params = this.extractParams(tool.inputSchema as ToolInputSchema);
    const commandName = `mcp:${serverName}:${tool.name}`;

    const briefHelp = generateBriefHelp({ commandName, description: tool.description, params });
    const detailedHelp = generateDetailedHelp({ commandName, description: tool.description, params });

    const requiredParams = params.filter((p) => p.required);
    const optionalParams = params.filter((p) => !p.required);

    return `#!/usr/bin/env bun
/**
 * MCP Tool Wrapper: ${commandName}
 *
 * Auto-generated by Synapse Agent MCP Wrapper Generator
 * Server: ${serverName}
 * Tool: ${tool.name}
 * Description: ${tool.description || 'No description'}
 */

const BRIEF_HELP = \`${briefHelp.replace(/`/g, '\\`')}\`;

const DETAILED_HELP = \`${detailedHelp.replace(/`/g, '\\`')}\`;

// Parse command line arguments
const args = process.argv.slice(2);

// Check for help flags
if (args.includes('-h')) {
  console.log(BRIEF_HELP);
  process.exit(0);
}

if (args.includes('--help')) {
  console.log(DETAILED_HELP);
  process.exit(0);
}

// Parse arguments
const positionalArgs: string[] = [];
const namedArgs: Record<string, string> = {};

for (const arg of args) {
  if (arg.startsWith('--')) {
    const eqIndex = arg.indexOf('=');
    if (eqIndex > 0) {
      const key = arg.slice(2, eqIndex);
      const value = arg.slice(eqIndex + 1);
      namedArgs[key] = value;
    } else {
      // Boolean flag
      namedArgs[arg.slice(2)] = 'true';
    }
  } else {
    positionalArgs.push(arg);
  }
}

// Build tool arguments
const toolArgs: Record<string, unknown> = {};

// Required parameters from positional args
const requiredParams = ${JSON.stringify(requiredParams.map((p) => ({ name: p.name, type: p.type })))};
for (let i = 0; i < requiredParams.length; i++) {
  const param = requiredParams[i];
  if (i >= positionalArgs.length) {
    console.error(\`Error: Missing required argument <\${param.name}>\`);
    console.error(BRIEF_HELP);
    process.exit(1);
  }
  toolArgs[param.name] = parseValue(positionalArgs[i], param.type);
}

// Optional parameters from named args
const optionalParams = ${JSON.stringify(optionalParams.map((p) => ({ name: p.name, type: p.type, defaultValue: p.defaultValue })))};
for (const param of optionalParams) {
  if (namedArgs[param.name] !== undefined) {
    toolArgs[param.name] = parseValue(namedArgs[param.name], param.type);
  } else if (param.defaultValue !== undefined) {
    toolArgs[param.name] = param.defaultValue;
  }
}

function parseValue(value: string, type: string): unknown {
  switch (type) {
    case 'number':
    case 'integer':
      return Number(value);
    case 'boolean':
      return value === 'true' || value === '1';
    case 'array':
      try {
        return JSON.parse(value);
      } catch {
        return value.split(',');
      }
    case 'object':
      return JSON.parse(value);
    default:
      return value;
  }
}

// Output the parsed arguments as JSON for the MCP caller
// Format: __MCP_CALL__:serverName:toolName:argsJson
console.log('__MCP_CALL__:${serverName}:${tool.name}:' + JSON.stringify(toolArgs));
`;
  }
}

export default McpWrapperGenerator;
